Fuse(Filesystem in Userspace)
kernel 에 대한 이해 없이 디버깅의 편리성, 시스템 안정성 향상, 개발 속도 같은 것들을 우선하는 filesystem 을 만들고 싶을 때 사용하는 것이 FUSE

filesystem 을 user layer 에서 개발할 수 있도록 도와주는 framework
linux, mac 등에서는 FUSE, windows 에서는 dokan 이 fuse 같은 framework 을 제공

---------------------------------------------------------------------------------------------------

libfuse를 가져다 쓰는 방법
- fuse_main에 fun pointer를 넣어서 호출

사용하지 않는 방법도 있다.
- fuse kernel module이 하는 일은 filesystem operation들을 /dev/fuse에 써주는 역할을 수행한다.
- libfuse는 /dev/fuse를 열고 주기적으로 해당 노드를 read하는 역할을 수행
 - 멀티 Thread로 High Performance, mmap(?) 등을 이용하여 kernel - user copy를 줄일 여지가 생긴다.

---------------------------------------------------------------------------------------------------

mmap
- 메모리에 상주하는 데이터 처럼 메모리를 통해 파일에 접근 가능
- /dev/fuse fd, offset 과 맵핑 되기를 원하는 addr을 넣어주어 사용 + Prot, Flags

대표적인 Prot 속성 

PROT_NONE - 접근이 불가능한 페이지 (거의 사용 되지 않는다.) 
PROT_READ - 읽기가 가능한 페이지 
PROT_WRITE - 쓰기가 가능한 페이지 
PROT_EXEC - 실행이 가능한 페이지 

대표적 Flags 속성 

MAP_FIXED - mmap의 addr인자를 요구사항으로 강제하는 것.  
MAP_PRIVATE - 맵이 공유 되지 않음 
MAP_SHARED -  맵이 공유 된다 

---------------------------------------------------------------------------------------------------

mmap 장, 단점
1. read(), write() 시스템 콜을 사용할 때 발생하는 불필요한 복사를 방지 가능하다(?)
2. 페이지 폴트가 일어나는 경우를 제외하고는 시스템 콜, 컨텍스트 스위칭에 따른 오버헤드가 없다. 

-1. 메모리 매핑은 페이지의 배수만큼만 가능하다는 점. 작은 파일을 매핑하는 경우, 낭비가 생긴다. 
-2. 32비트 시스템에서의 경우에는 주소 공간의 파편화를 초래할 가능성이 크다. 
-3. 커널 내부에서 매핑 관련 된 자료구조를 유지하는데 오버헤드가 발생하게 된다. 

---------------------------------------------------------------------------------------------------

read(), write() 시스템 콜을 사용할 때 발생하는 불필요한 복사란?

---------------------------------------------------------------------------------------------------

페이지 폴트, 컨텍스트 스위칭

---------------------------------------------------------------------------------------------------